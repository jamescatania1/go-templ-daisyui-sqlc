// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE user_id=$1 AND expires_at < $2
`

type DeleteExpiredRefreshTokensParams struct {
	UserID    uuid.UUID
	ExpiresAt time.Time
}

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context, arg DeleteExpiredRefreshTokensParams) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens, arg.UserID, arg.ExpiresAt)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens WHERE id = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRefreshToken, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, password_hash, created_at, email_verified FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.EmailVerified,
	)
	return i, err
}

const getUserandRefreshToken = `-- name: GetUserandRefreshToken :one
SELECT refresh_tokens.id, refresh_tokens.user_id, refresh_tokens.token, refresh_tokens.created_at, refresh_tokens.expires_at, users.id, users.email, users.name, users.password_hash, users.created_at, users.email_verified,
    (SELECT COUNT(*) FROM refresh_tokens r WHERE r.user_id = $1) AS token_count
FROM users
JOIN refresh_tokens ON users.id = refresh_tokens.user_id
WHERE users.id = $1
`

type GetUserandRefreshTokenRow struct {
	RefreshToken RefreshToken
	User         User
	TokenCount   int64
}

func (q *Queries) GetUserandRefreshToken(ctx context.Context, userID uuid.UUID) (GetUserandRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserandRefreshToken, userID)
	var i GetUserandRefreshTokenRow
	err := row.Scan(
		&i.RefreshToken.ID,
		&i.RefreshToken.UserID,
		&i.RefreshToken.Token,
		&i.RefreshToken.CreatedAt,
		&i.RefreshToken.ExpiresAt,
		&i.User.ID,
		&i.User.Email,
		&i.User.Name,
		&i.User.PasswordHash,
		&i.User.CreatedAt,
		&i.User.EmailVerified,
		&i.TokenCount,
	)
	return i, err
}

const insertNewEmailVerification = `-- name: InsertNewEmailVerification :one
INSERT INTO email_verifications (user_id)
VALUES ($1)
RETURNING id, user_id, created_at
`

func (q *Queries) InsertNewEmailVerification(ctx context.Context, userID uuid.UUID) (EmailVerification, error) {
	row := q.db.QueryRow(ctx, insertNewEmailVerification, userID)
	var i EmailVerification
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const insertNewRefreshToken = `-- name: InsertNewRefreshToken :exec
INSERT INTO refresh_tokens (id, user_id, token, expires_at)
VALUES ($1, $2, $3, $4)
`

type InsertNewRefreshTokenParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Token     string
	ExpiresAt time.Time
}

func (q *Queries) InsertNewRefreshToken(ctx context.Context, arg InsertNewRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, insertNewRefreshToken,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
	)
	return err
}

const insertNewUser = `-- name: InsertNewUser :one
INSERT INTO users (email, name, password_hash, email_verified)
VALUES ($1, $2, $3, $4)
RETURNING id, email, name, password_hash, created_at, email_verified
`

type InsertNewUserParams struct {
	Email         string
	Name          string
	PasswordHash  string
	EmailVerified bool
}

func (q *Queries) InsertNewUser(ctx context.Context, arg InsertNewUserParams) (User, error) {
	row := q.db.QueryRow(ctx, insertNewUser,
		arg.Email,
		arg.Name,
		arg.PasswordHash,
		arg.EmailVerified,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.EmailVerified,
	)
	return i, err
}
